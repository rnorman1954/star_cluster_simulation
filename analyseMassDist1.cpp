              // Date-stamp: <2019 09 29>
             //================================================================
            //                                                                |
           //           /__----__                         ........            |
          //       .           \                     ....:        :.          |
         //       :                 _\|/_         ..:                         |
        //       :                   /|\         :                     _\|/_  |
       //  ___   ___                  _____                      ___    /|\   |
      //  /     |   \    /\ \     / |   |   \  / |        /\    |   \         |
     //  |   __ |___/   /  \ \   /  |   |    \/  |       /  \   |___/         |
    //   |    | |  \   /____\ \ /   |   |    /   |      /____\  |   \     \/  |
   //     \___| |   \ /      \ V    |   |   /    |____ /      \ |___/     |   |
  //                                                                      /   |
 //              :                       _/|     :..                    |/    |
//                :..               ____/           :....          ..         |
/*   o   //          :.    _\|/_     /                   :........:           |
 *  O  `//\                 /|\                                               |
 *  |     /\                                                                  |
 *=============================================================================
 *
 *  analyseMassDist.cpp:  analyses the distribution of masses generated by the
 *                          createCluster routine.  Used to check if the
 *                          distribution os correct for the simulation.
 *_____________________________________________________________________________
 *
 *  usage: analyseMassDist
 *
 *         The routine reads the masses from stdin in the format
 *         specified below.  Since the createCluster routine normalises the
 *         masses so the total mass of the cluster is unity then the masses
 *         of the stars are between zero amd 1/N.  This routine places them
 *         in histogram bins of width 0.1/N.
 *         It outputs to a stdout and a temporary file, plots a histogram of
 *         the data, and then removes the temporary file.
 *
 *         Requires an input file in the following format,
 *         for particle number, time, and masses mi,
 *         positions ri, and velocities vi for particles i:
 *
 *                      3
 *                      0
 *                      m1 r1_x r1_y r1_z v1_x v1_y v1_z
 *                      m2 r2_x r2_y r2_z v2_x v2_y v2_z
 *                      m3 r3_x r3_y r3_z v3_x v3_y v3_z
 *
 *         Example usage:
 *              analyseMassDist < data.in
 *
 *         Output consists of the 'num_bin' numbers representing the frequency of stars
 *         in each column of the bin.
 *         eg.  num_bin = 10 and rescaling = true
                Bin       Frequency
 *              0.0-->0.1   39
 *              0.1-->0.2   51
 *              ...
 *              0.9-->1.0   29
 *
 *          Usage:  analyseMassDist
 *                          -b number of sorting bins
 *                          -m maximum mass to be plotted
 *                          [-r turn off mass rescaling]
 *                          [-h (for help)]
 *
 *_____________________________________________________________________________
 *
 *    version 2:
 *____________________________________________________________________________*/

#include <iostream>
#include <fstream>      //For file creation
#include <stdio.h>      //For fprintf, FILE
#include <cstdlib>      //For system()
#include <unistd.h>     // for getopt()
#include <math.h>       //For log function

using namespace std;

typedef double real;    //Enables easy redefinitio at a later date if required.
const int NDIM = 3;     //Number of dimensions of space

//Function declarations
bool read_options(int argc, char *argv[], int &num_bins, real &mass_max, bool &rescale);


int main(int argc, char *argv[]) {

    int n = 0;              //Number of stars in cluster
    real t = 0.0;           //Time
    int num_bins = 0;        //The number of sorting bins
    double mass_max = 0.0;    //The largest mass allowable for the distribution
    bool rescale = true;    //The masses have been rescaled to a cluster mass of unity-default

    if (! read_options(argc, argv, num_bins, mass_max, rescale))
        return 1;

    cin >> n;               //Read the number of stars and
    cin >> t;               //the time from the input stream

    real mass = 0.0;            //mass of each star
    real *bin = new real[num_bins];   //Bin to hold histogram information

    //Initialise bin
    for(int i = 0; i < num_bins; i++) {
        bin[i] = 0.0;
    }

    real binWidth;
    //Determine the width of the bins
    if(rescale) {
        binWidth = 1.0/(n*num_bins);    //Stellar masses equal average of 1/n
    }else{
        binWidth = mass_max/num_bins;  //Stellar masses in ratios of M_sun
    }

    //Read and categorise masses
    real dummy;
    real mass_cluster_tot = 0.0;
    real mass_largest = 0.0;                            //used to discard the other values in the file.
    for(int i = 0; i < n; i++) {
        cin >> mass;                       // mass of particle i
        for (int k = 0; k < NDIM; k++)
            cin >> dummy;                 // position of particle i --> discard
        for (int k = 0; k < NDIM; k++)
            cin >> dummy;                 // velocity of particle i --> discard

        mass_cluster_tot += mass;

        //Determine largest mass
        if(mass_largest<mass)
            mass_largest = mass;

        //Determine which bin for each mass
        for(int j = 0; j < num_bins; j++) {
            if(mass >= j*binWidth && mass < (j+1)*binWidth)
                bin[j]++;
        }
    }

    cerr << "Total cluster mass = " << mass_cluster_tot << endl;
    cerr << "Largest star in cluster has mass = " << mass_largest << endl;

    //Output the frequency table to stdout
    cout << "Bin   Frequency" << endl;    //Labels
    for(int i = 0; i < num_bins; i++) {
        cout << (i)*binWidth << "\t" << bin[i] << "\t" << log10(bin[i]) << endl;
    }

    //Output the frequency table to a temp file for gnuplot
    ofstream out("histo.txt");
    if(!out) {
        cout << "Cannot open temporary file 'histo.txt'" << endl;
        return 1;
    }
    out << "Bin Frequency" << endl;    //Labels
    for(int i = 0; i < num_bins; i++) {
        out << (i)*binWidth << " " << bin[i] << " " << (bin[i]>0?log10(bin[i]):0.0) << endl;
    }
    out.close();

            //#define GNUPLOT_NAME "pgnuplot.exe -persist"      //This version for screen window in Win
            //#define GNUPLOT_NAME "pgnuplot.exe"               //This version for file creation in Win
            #define GNUPLOT_NAME "gnuplot -persist"             //This version for file & screen creation in Linux
            FILE *pipe = popen(GNUPLOT_NAME, "w");

            if (pipe != NULL)
            {
                fprintf(pipe, "set key off\n");
                fprintf(pipe, "set yrange [0:*]\n");
                fprintf(pipe, "set boxwidth 1.0\n");
                fprintf(pipe, "set style fill solid 1.00 border lt -1\n");
                fprintf(pipe, "set style histogram clustered gap 0.5\n");
                fprintf(pipe, "set style data histogram\n");
                fprintf(pipe, "set tics out\n");
                fprintf(pipe, "set grid ytics\n");

                fprintf(pipe, "set term x11 0\n");     //set the terminal to x11 for Gnome desktop -window 0
                fprintf(pipe, "plot 'histo.txt' using 2:xtic(1)\n");

                fprintf(pipe, "set term x11 1\n");     //set the terminal to x11 for Gnome desktop -window 1
                fprintf(pipe, "plot 'histo.txt' using 3:xtic(1) ti col\n");    // plot data from temp file

//                fprintf(pipe, "set output \n");          //Set output to nothing - required for windows

                fflush(pipe);                          // flush and
                pclose(pipe);                          // close the pipe
            }//end if pipe
            else
                printf("Could not open the pipe\n");

            //system("rm histo.txt");     //Remove the temporary file

    delete bin;
    return 0;
}

/*-----------------------------------------------------------------------------
 *  read_options  --  reads the command line options, and implements them.
 *
 *  note: when the help option -h is invoked, the return value is set to false,
 *        to prevent further execution of the main program; similarly, if an
 *        unknown option is used, the return value is set to false.
 *-----------------------------------------------------------------------------
 */

bool read_options(int argc, char *argv[], int &num_bins, real &mass_max, bool &rescale)
{
    int c;
    while ((c = getopt(argc, argv, "hb:m:r")) != -1)       //colon indicates the option has an argument following
        switch(c){
            case 'b': num_bins = atoi(optarg);
                      break;
            case 'm': mass_max = atof(optarg);
                      break;
            case 'r': rescale = false;
                      break;
            case 'h':
            case '?': cerr << "usage: " << argv[0] << endl
                           << "         -b number of sorting bins\n"
                           << "         -m maximum mass to be plotted\n"
                           << "         [-r turn off mass rescaling]\n"
                           << "         [-h (for help)]\n"
                           << endl;
                      return false;      // execution stops after help or error
            }
    if(num_bins==0 || (!rescale && !(mass_max > 0.0)) ){
        cerr << endl
             << "You must enter the number of sorting bins,\n"
             << "      -b num_of_bins\n"
             << "and, a maximum mass to be plotted if rescale is off.\n"
             << "      -m max_mass."
             << endl << endl;
        return false;
    }

    return true;                         // ready to continue program execution
}
